## Spring Boot 계층 흐름도
![alt text](Study.img/springflowchart.png)

## Entity(Domain) - JPA
- Entiry 어노테이션 사용
- 데이터베이스에 쓰일 컬럼과 여러 Entity 간의 연관 관계를 정의 하는 클래스를 의미
- 데이터베이스의 테이블을 하나의 Entity로 생각해도 무방함
- 실제 데이터베이스의 테이블과 1:1로 매핑이 되도록 설계함
- 이 클래스의 필드는 각 테이블 내부의 컬럼(Columm)을 의미
___

### JPA

```java
package My.Spring_Study.domain;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.Id;

@Entity
@Getter
@Setter
public class User {
    @jakarta.persistence.Id
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 기본 키(primary key)를 자동으로 생성
    private Long id;

    @Column(nullable = false) // not null
    private String name;

    @Column(nullable = false, unique = true) // 컬럼의 값이 중복될 수 없음
    private String email;

    private String phone;

    // 기본 생성자 (필수)
    public User() {
    }

    // 모든 필드를 초기화하는 생성자
    public User(Long id, String name, String email, String phone) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.phone = phone;
    }
}
```

___

### 만약 JPA를 사용하지 않는다면 User 클래스는 일반적인 Java 객체로 취급되어 데이터베이스와의 매핑은 개발자가 직접 SQL로 관리하여야 한다(DAO).

### POJO (Plain, Old, Java, Object)

```Java
public class User {
    private Long id;
    private String email;
    private String name;
    private String phone;
}
```
___
### 

```java
// Insert User
String sql = "INSERT INTO User (email, name) VALUES (?, ?)";
PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
pstmt.setString(1, user.getEmail());
pstmt.setString(2, user.getName());
pstmt.executeUpdate();

// Retrieve the generated ID
ResultSet rs = pstmt.getGeneratedKeys();
if (rs.next()) {
    user.setId(rs.getLong(1));
}
```
___

## Repository
- Entity에 의해 생성된 데이터베이스 테이블에 접근하는 메소드를 사용하기 위한 인터페이스
- Service와 DB를 연결하는 고리의 역할을 수행
- 데이터베이스에 적용하고자 하는 CRUD를 정의하는 영역
___

```java
package My.Spring_Study.repository;

import My.Spring_Study.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User,Integer> {
}

```
___
Repository Interface는 데이터 베이스와 직접 소통하는 데이터 엑세스 계층이며 데이터 처리 및 추가적인 비즈니스 규칙이 적용되어야 하는 경우, Repository에서 직접 처리하면 코드가 복잡해지고 책임이 모호해진다.
하여 Service 계층을 만들어 비즈니스 로직을 분리하여 코드의 역할을 명확하게 하기 위해 사용된다.
즉, Service 레이어에서 UserRepository interface를 통해 DB에 접근하여 CRUD를 구현하며 UserRepository가 DB역할을 하는 것이다.


## Service 
- Service 어노테이션 사용
- 비즈니스 로직 처리
- 데이터 통합
- 트랙잭션 곤리
- 유지보수성 향상

```java
package My.Spring_Study.service;

import My.Spring_Study.domain.User;
import My.Spring_Study.repository.UserRepository;

public class UserService {

    //객체 상태 저장
    private final UserRepository userRepository;

    //의존성 주입
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User insertUser(String name, String email, String phone){
        //User Entity
        User user = new User();
        user.setName(name);
        user.setEmail(email);
        user.setPhone(phone);

        return userRepository.save(user);
    }
}
```
___
User 정보를 받아와 DB에 저장하는 로직을 Service 레이어로 구현한다고 하였을 때 Service 레이어는 User정보를 Repository에 똑같이 전달해야하기 때문에
결국 Service 객체의 값이 먼저 DB에 저장하기 위해 DB에 저장하는 역할을 하는 UserRepository 객체를 UserService 객체에 주입시켜야 한다.
User 정보를 받아온 다음 userRepository.save(user)하게 되면 user 정보의 값이 들어가 있는 UserService 객체의 값이 UserRepository의 메소드인 save를 사용하여 
DB에 User정보가 저장되게 된다.


### Controller

```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // 비즈니스 로직: 이메일 중복 확인
        if (userRepository.existsByEmail(user.getEmail())) {
            return ResponseEntity.badRequest().body(null);
        }

        // 데이터베이스에 저장
        User savedUser = userRepository.save(user);

        return ResponseEntity.ok(savedUser);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // 데이터 조회 및 예외 처리
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found"));

        return ResponseEntity.ok(user);
    }
}

```
___

컨트롤러에서 Repository를 직접 호출하여 데이터베이스와 상호작용하고 비즈니스 로직이 컨트롤러에 포함되어 코드가 복잡해지고 역할이 명확하지 않다.
___

### Service 레이어를 사용하는 경우

### Controller

```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // Service에 위임
        User savedUser = userService.createUser(user);
        return ResponseEntity.ok(savedUser);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Service에 위임
        User user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
}
```
___

### Service

```java
@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User createUser(User user) {
        // 비즈니스 로직: 이메일 중복 확인
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new IllegalArgumentException("Email already exists");
        }

        // 데이터베이스에 저장
        return userRepository.save(user);
    }

    public User getUserById(Long id) {
        // 데이터 조회 및 예외 처리
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found"));
    }
}
```
___

### 비교 

| 특징         | Service 레이어 없음                     | Service 레이어 있음                      |
|--------------|-----------------------------------------|------------------------------------------|
| 비즈니스 로직 위치 | 컨트롤러에 비즈니스 로직이 포함됨         | Service에 비즈니스 로직이 포함됨          |
| 역할 분리     | 컨트롤러와 Repository의 역할이 불분명      | Controller는 요청 처리, Service는 비즈니스 로직 |
| 코드 재사용성  | 컨트롤러 간 동일한 로직 중복              | Service를 통해 재사용 가능               |
| 유지보수성    | 수정 범위가 커짐                        | 각 계층이 독립적이라서 수정 범위가 작음       |
| 테스트 가능성  | 단위 테스트가 어려움                    | Service를 단위 테스트할 수 있음           |
| 확장성       | 추가 요구사항 반영 시 코드가 복잡해짐       | 비즈니스 로직이 독립적이라 확장에 유리       |


___

서비스 레이어를 사용하지 않는 경우, 컨트롤러에서 비즈니스 로직과 데이터베이스 접근 로직을 모두 처리하게 된다. 이 방식은 단순한 기능을 구현할 때는 코드의 계층 구조가 단순한 기능일 때는 유용할 수 있으나
프로젝트 규모가 커지고 비즈니스 로직이 복잡해질수록 컨트롤러의 역할이 커지고 중첩 될 경우 수정이 필요할 때 수정하는 범위가 넓어져 코드의 유지보수와 테스트가 어려워지는 문제가 발생한다.
하지만, 서비스 레이어를 사용하는 경우, 컨트롤러와 비즈니스 로직, 그리고 데이터 접근 로직을 명확히 분리할 수 있어 컨트롤러는 클라이언트 요청을 받아 적절한 서비스 메서드를 호출하는 역할만 하고, 비즈니스
로직은 서비스 계층에서 처리하는 방식으로 프로젝트가 대규모로 확장되거나 복잡한 비즈니스 로직이 많은 경우 유용하다.

___


## DAO(Data Access Object)
- 데이터베이스에 접근하는 객체를 의미(Persistance Layer)
- Service가 DB에 연결할 수 있게 해주는 역할
- DB를 사용하여 데이터를 조회하거나 조작하는 기능을 전담
- Repository와 마찬가지로 데이터베이스와 상호 작용을 담당

## JDBC 사용

### User

```java
public class User {
    private Long id;
    private String email;
    private String name;

    // Getters and Setters
    // ...
}
```

### UserDAO (JDBC)

```java

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class UserDAO {
    private final Connection connection;

    public UserDAO(Connection connection) {
        this.connection = connection;
    }

    // 사용자 저장
    public Long saveUser(User user) throws SQLException {
        String sql = "INSERT INTO users (email, name) VALUES (?, ?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, user.getEmail());
            pstmt.setString(2, user.getName());
            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                Long generatedId = rs.getLong(1);
                user.setId(generatedId);
                return generatedId;
            }
        }
        return null;
    }

    // ID로 사용자 조회
    public User findUserById(Long id) throws SQLException {
        String sql = "SELECT * FROM users WHERE id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setLong(1, id);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    User user = new User();
                    user.setId(rs.getLong("id"));
                    user.setEmail(rs.getString("email"));
                    user.setName(rs.getString("name"));
                    return user;
                }
            }
        }
        return null;
    }

    // 모든 사용자 조회
    public List<User> findAllUsers() throws SQLException {
        String sql = "SELECT * FROM users";
        List<User> users = new ArrayList<>();

        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            while (rs.next()) {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setEmail(rs.getString("email"));
                user.setName(rs.getString("name"));
                users.add(user);
            }
        }
        return users;
    }

    // 사용자 삭제
    public void deleteUser(Long id) throws SQLException {
        String sql = "DELETE FROM users WHERE id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setLong(1, id);
            pstmt.executeUpdate();
        }
    }
}
```
___
### UserService 
```java
public class UserService {
    private final UserDAO userDAO;

    public UserService(UserDAO userDAO) {
        this.userDAO = userDAO;
    }

    public Long registerUser(String email, String name) throws SQLException {
        User user = new User();
        user.setEmail(email);
        user.setName(name);
        return userDAO.saveUser(user);
    }

    public User getUserById(Long id) throws SQLException {
        return userDAO.findUserById(id);
    }

    public List<User> getAllUsers() throws SQLException {
        return userDAO.findAllUsers();
    }

    public void removeUser(Long id) throws SQLException {
        userDAO.deleteUser(id);
    }
}
```

### UserController

```java
import java.sql.SQLException;
import java.util.List;

public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    public void createUser(String email, String name) {
        try {
            userService.registerUser(email, name);
            System.out.println("사용자 등록 완료");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void displayUser(Long id) {
        try {
            User user = userService.getUserById(id);
            if (user != null) {
                System.out.println("ID: " + user.getId());
                System.out.println("Email: " + user.getEmail());
                System.out.println("Name: " + user.getName());
            } else {
                System.out.println("사용자를 찾을 수 없습니다.");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void displayAllUsers() {
        try {
            List<User> users = userService.getAllUsers();
            for (User user : users) {
                System.out.println("ID: " + user.getId() + ", Email: " + user.getEmail() + ", Name: " + user.getName());
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void deleteUser(Long id) {
        try {
            userService.removeUser(id);
            System.out.println("사용자 삭제 완료");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


```


## DTO(Data Transfer Object)

- DTO는 VO(Value Object)로 불리기도 하며, 계층간 데이터 교환(Client → Controller → Service)을 위한 객체를 의미(Entity와 달리 데이터베이스의 필드 값에 독립적이다.)
- 데이터를 단순히 담고 전달하는 역할을 하며, 로직은 포함하지 않는다.
- JPA 엔티티나 도메인 객체외 1:1 매핑되거나 필요한 일부 데이터만 포함된다.
- VO의 경우 Read Only의 개념을 가지고 있다.

### DTO

```java
public class UserDTO {
    private Long id;
    private String name;
    private String email;

    // 기본 생성자
    public UserDTO() {}

    // 모든 필드를 초기화하는 생성자
    public UserDTO(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    // Getter와 Setter
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getEmail() {
        return email;
    }
    public void setEmail(String email) {
        this.email = email;
    }

    // toString 메서드 (디버깅 및 로깅에 유용)
    @Override
    public String toString() {
        return "UserDTO{" +
               "id=" + id +
               ", name='" + name + '\'' +
               ", email='" + email + '\'' +
               '}';
    }
}
```

### Controller

```java
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {

    // 사용자 생성 (예제)
    @PostMapping
    public String createUser(@RequestBody UserDTO userDTO) {
        // DTO로 데이터를 받아 처리
        System.out.println("Received User: " + userDTO);

        // 비즈니스 로직 처리 후 성공 응답 반환
        return "User created successfully: " + userDTO.getName();
    }

    // 사용자 조회 (예제)
    @GetMapping("/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        // 예제 데이터 (보통은 서비스 계층에서 가져옴)
        UserDTO userDTO = new UserDTO(id, "John Doe", "johndoe@example.com");

        // DTO를 응답으로 반환
        return userDTO;
    }
}
```

### Service

```java
import org.springframework.stereotype.Service;

@Service
public class UserService {

    // 사용자 생성 예제
    public void createUser(UserDTO userDTO) {
        // 사용자 데이터 저장 로직 (예제에서는 단순 출력)
        System.out.println("Saving user: " + userDTO);
    }

    // 사용자 조회 예제
    public UserDTO getUserById(Long id) {
        // 데이터베이스에서 가져온 데이터를 기반으로 DTO 반환 (예제 데이터)
        return new UserDTO(id, "Jane Smith", "janesmith@example.com");
    }
}
```

