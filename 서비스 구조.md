Spring Boot 서비스구조

## Entity(Domain) - JPA

- 데이터베이스에 쓰일 컬럼과 여러 Entity 간의 연관 관계를 정의 하는 클래스를 의미
- 데이터베이스의 테이블을 하나의 Entity로 생각해도 무방함
- 실제 데이터베이스의 테이블과 1:1로 매핑이 되도록 설계함
- 이 클래스의 필드는 각 테이블 내부의 컬럼(Columm)을 의미

___

```java
package com.example.demo.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.persistence.*;

@Entity
@Getter
@Setter
@NoArgsConstructor // 기본 생성자 자동생성 
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 기본 키(primary key)를 자동으로 생성
    private Long id;

    @Column(nullable = false) // not null
    private String name;

    @Column(nullable = false, unique = true) // 컬럼의 값이 중복될 수 없음
    private String email;

    private String phone;
}
```
___


```java
// User 엔티티 저장
User user = new User();
user.setEmail("example@example.com");
user.setName("John Doe");

// JPA EntityManager를 사용하여 데이터베이스에 저장
entityManager.persist(user);

// persist 메서드는 엔티티를 저장하고, 저장된 엔티티의 ID를 자동으로 설정합니다.
Long generatedId = user.getId();
System.out.println("Generated ID: " + generatedId);
```

___

### 만약 JPA를 사용하지 않는다면 User 클래스는 일반적인 Java 객체 (POJO = Plain, Old, Java, Object)로 취급되어 데이터베이스와의 매핑은 개발자가 직접 SQL로 관리하여야 한다.

```Java
public class User {
    private Long id;
    private String email;
    private String name;

    // Getters and Setters
}
```

___

```java
// Insert User
String sql = "INSERT INTO User (email, name) VALUES (?, ?)";
PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
pstmt.setString(1, user.getEmail());
pstmt.setString(2, user.getName());
pstmt.executeUpdate();

// Retrieve the generated ID
ResultSet rs = pstmt.getGeneratedKeys();
if (rs.next()) {
    user.setId(rs.getLong(1));
}
```
___


## Repository

- Entity에 의해 생성된 데이터베이스 테이블에 접근하는 메소드를 사용하기 위한 인터페이스
- Service와 DB를 연결하는 고리의 역할을 수행
- 데이터베이스에 적용하고자 하는 CRUD를 정의하는 영역
___

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// JpaRepository<User, Long> : User Entity를 다루며, 기본 키 타입이 Long임을 의미
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // 커스텀 쿼리 메소드 예시
    User findByEmail(String email);
}
```

### Repository를 사용하기 위해서 Service 계층을 만들어 코드를 작성한다.
Repository Interface는 데이터 베이스와 직접 소통하는 데이터 엑세스 계층이며 데이터 처리 및 추가적인 비즈니스 규칙이 적용되어야 하는 경우, Repository에서 직접 처리할 경우 코드가 복잡해지고 책임이 모호해진다.
하여 Service 계층을 만들어 비즈니스 로직을 분리하여 코드의 역할을 명확하게 하기 위해 사용된다.

### Service 레이어를 사용하지 않은 경우

### Controller

```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // 비즈니스 로직: 이메일 중복 확인
        if (userRepository.existsByEmail(user.getEmail())) {
            return ResponseEntity.badRequest().body(null);
        }

        // 데이터베이스에 저장
        User savedUser = userRepository.save(user);

        return ResponseEntity.ok(savedUser);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // 데이터 조회 및 예외 처리
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found"));

        return ResponseEntity.ok(user);
    }
}

```
___

컨트롤러에서 Repository를 직접 호출하여 데이터베이스와 상호작용하고 비즈니스 로직이 컨트롤러에 포함되어 코드가 복잡해지고 역할이 명확하지 않다.
___

### Service 레이어를 사용하는 경우

### Controller

```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // Service에 위임
        User savedUser = userService.createUser(user);
        return ResponseEntity.ok(savedUser);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Service에 위임
        User user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
}
```
___

### Service

```java
@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User createUser(User user) {
        // 비즈니스 로직: 이메일 중복 확인
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new IllegalArgumentException("Email already exists");
        }

        // 데이터베이스에 저장
        return userRepository.save(user);
    }

    public User getUserById(Long id) {
        // 데이터 조회 및 예외 처리
        return userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found"));
    }
}
```
___

### 비교 

| 특징         | Service 레이어 없음                     | Service 레이어 있음                      |
|--------------|-----------------------------------------|------------------------------------------|
| 비즈니스 로직 위치 | 컨트롤러에 비즈니스 로직이 포함됨         | Service에 비즈니스 로직이 포함됨          |
| 역할 분리     | 컨트롤러와 Repository의 역할이 불분명      | Controller는 요청 처리, Service는 비즈니스 로직 |
| 코드 재사용성  | 컨트롤러 간 동일한 로직 중복              | Service를 통해 재사용 가능               |
| 유지보수성    | 수정 범위가 커짐                        | 각 계층이 독립적이라서 수정 범위가 작음       |
| 테스트 가능성  | 단위 테스트가 어려움                    | Service를 단위 테스트할 수 있음           |
| 확장성       | 추가 요구사항 반영 시 코드가 복잡해짐       | 비즈니스 로직이 독립적이라 확장에 유리       |


___

서비스 레이어를 사용하지 않는 경우, 컨트롤러에서 비즈니스 로직과 데이터베이스 접근 로직을 모두 처리하게 된다. 이 방식은 단순한 기능을 구현할 때는 코드의 계층 구조가 단순한 기능일 때는 유용할 수 있으나
프로젝트 규모가 커지고 비즈니스 로직이 복잡해질수록 컨트롤러의 역할이 커지고 중첩 될 경우 수정이 필요할 때 수정하는 범위가 넓어져 코드의 유지보수와 테스트가 어려워지는 문제가 발생한다.
하지만, 서비스 레이어를 사용하는 경우, 컨트롤러와 비즈니스 로직, 그리고 데이터 접근 로직을 명확히 분리할 수 있어 컨트롤러는 클라이언트 요청을 받아 적절한 서비스 메서드를 호출하는 역할만 하고, 비즈니스
로직은 서비스 계층에서 처리하는 방식으로 프로젝트가 대규모로 확장되거나 복잡한 비즈니스 로직이 많은 경우 유용하다.

___


## DAO(Data Access Object)
- 데이터베이스에 접근하는 객체를 의미(Persistance Layer)
- Service가 DB에 연결할 수 있게 해주는 역할
- DB를 사용하여 데이터를 조회하거나 조작하는 기능을 전담
- Repository와 마찬가지로 데이터베이스와 상호 작용을 담당

## JDBC 사용

### User

```java
public class User {
    private Long id;
    private String email;
    private String name;

    // Getters and Setters
    // ...
}
```

### UserDAO (JDBC)

```java

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class UserDAO {
    private final Connection connection;

    public UserDAO(Connection connection) {
        this.connection = connection;
    }

    // 사용자 저장
    public Long saveUser(User user) throws SQLException {
        String sql = "INSERT INTO users (email, name) VALUES (?, ?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, user.getEmail());
            pstmt.setString(2, user.getName());
            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                Long generatedId = rs.getLong(1);
                user.setId(generatedId);
                return generatedId;
            }
        }
        return null;
    }

    // ID로 사용자 조회
    public User findUserById(Long id) throws SQLException {
        String sql = "SELECT * FROM users WHERE id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setLong(1, id);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    User user = new User();
                    user.setId(rs.getLong("id"));
                    user.setEmail(rs.getString("email"));
                    user.setName(rs.getString("name"));
                    return user;
                }
            }
        }
        return null;
    }

    // 모든 사용자 조회
    public List<User> findAllUsers() throws SQLException {
        String sql = "SELECT * FROM users";
        List<User> users = new ArrayList<>();

        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            while (rs.next()) {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setEmail(rs.getString("email"));
                user.setName(rs.getString("name"));
                users.add(user);
            }
        }
        return users;
    }

    // 사용자 삭제
    public void deleteUser(Long id) throws SQLException {
        String sql = "DELETE FROM users WHERE id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setLong(1, id);
            pstmt.executeUpdate();
        }
    }
}
```
___
### UserService 
```java
public class UserService {
    private final UserDAO userDAO;

    public UserService(UserDAO userDAO) {
        this.userDAO = userDAO;
    }

    public Long registerUser(String email, String name) throws SQLException {
        User user = new User();
        user.setEmail(email);
        user.setName(name);
        return userDAO.saveUser(user);
    }

    public User getUserById(Long id) throws SQLException {
        return userDAO.findUserById(id);
    }

    public List<User> getAllUsers() throws SQLException {
        return userDAO.findAllUsers();
    }

    public void removeUser(Long id) throws SQLException {
        userDAO.deleteUser(id);
    }
}
```

### UserController

```java
import java.sql.SQLException;
import java.util.List;

public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    public void createUser(String email, String name) {
        try {
            userService.registerUser(email, name);
            System.out.println("사용자 등록 완료");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void displayUser(Long id) {
        try {
            User user = userService.getUserById(id);
            if (user != null) {
                System.out.println("ID: " + user.getId());
                System.out.println("Email: " + user.getEmail());
                System.out.println("Name: " + user.getName());
            } else {
                System.out.println("사용자를 찾을 수 없습니다.");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void displayAllUsers() {
        try {
            List<User> users = userService.getAllUsers();
            for (User user : users) {
                System.out.println("ID: " + user.getId() + ", Email: " + user.getEmail() + ", Name: " + user.getName());
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void deleteUser(Long id) {
        try {
            userService.removeUser(id);
            System.out.println("사용자 삭제 완료");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


```


## DTO(Data Transfer Object)

- DTO는 VO(Value Object)로 불리기도 하며, 계층간 데이터 교환(Client → Controller → Service)
을 위한 객체를 의미(Entity와 달리 데이터베이스의 필드 값에 독립적이다.)
- VO의 경우 Read Only의 개념을 가지고 있음